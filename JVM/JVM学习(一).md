# JVM学习

## 1.类加载器机制

### 1.1 什么是类加载

> **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。**类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
>
> 在Java代码中，类的加载，连接与初始化过程都是在**程序运行期间**完成的。
>
> 提供了更大的灵活性，增加了更多的可能性。

### 1.2 Java虚拟机与程序的生命周期

![生命](C:\Users\Administrator\Desktop\笔记\JVM\images\生命.jpg)

> **其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。**在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
>
> 在如下几种情况下，Java虚拟机将结束生命周期
>
> * 执行了System.exit()方法
> * 程序正常执行结束
> * 程序在执行过程中遇到了异常或错误而异常终止
> * 由于操作系统出现操作而导致Java虚拟机进程终止

### 1.3 类的加载，连接与初始化

> * 加载：查找并加载类的二进制数据
> * 连接
>       * 验证：确保被加载类的正确性
>       * 准备：为类的**静态变量**分配内存，并将其**初始化为默认值**
>       * 解析：把类的符号引用转换为直接引用
> * 初始化：**为类的静态变量赋予正确的初始化**
> * 使用
> * 卸载

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.jpg)

> Java程序对类的使用方式可分为两种
>
> * 主动使用
> * 被动使用
>
> 所有的Java虚拟机实现必须在每个类或接口被Java程序"**首次主动使用**"时才初始化它们。

#### 1.3.1 加载

> 查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
>
> - 通过一个类的全限定名来获取其定义的二进制字节流。  
> - 将这个字节流所代表的静态存储结构(.class文件)转化为方法区的运行时数据结构。  
> - 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口。
>
> 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
>
> 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

#### 1.3.2 连接

> **验证：确保被加载的类的正确性**
>
> 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
>
> * 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
> * 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
> * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
> * 符号引用验证：确保解析动作能正确执行。
>
> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-`Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
>
> **准备：为类的静态变量分配内存，并将其初始化为默认值**
>
> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
>
> * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
>
> * 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
>
> * 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
>
>   假设上面的类变量value被定义为： public static final int value = 3；
>   
>
> 假设一个类变量的定义为：public static int value = 3；
>
> 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的public static指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
>
> **这里还需要注意如下几点：**
>
> - 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
> - **对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，**总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
> - 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
> - 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值
>
> **解析：把类中的符号引用转换为直接引用**
>
> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
>
> 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 1.3.3 初始化

> **初始化:  为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式**：
>
> * 声明类变量是指定初始值
> * 使用静态代码块为类变量指定初始值
>
> JVM初始化步骤
>
> 1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
> 2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
> 3. 假如类中有初始化语句，则系统依次执行这些初始化语句 

### 1.4 类的主动使用(七种)

> * 创建类的实例(new)
> * 访问某个类或接口的静态变量，或者对该静态变量赋值
> * 调用类的静态方法
> * 反射（如Class.forName("com.test.Test")）
> * 初始化一个类的子类
> * Java虚拟机启动时被标明为启动类的类(包含有main()的类)
> * JDK1.7开始提供的动态语言支持(java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化)
>
> 除了以上七种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都**不会导致类的初始化**

### 1.5 类的加载含义

> **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象**（规范并未说明Class 对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封闭类在方法区内的数据结构。

### 1.6 加载.class文件的方式

> * 从本地系统中直接加载
> * 通过网络下载.class文件
> * 从zip,jar等归档文件中加载.class 文件
> * 从专有数据库中提取.class 文件
> * **将Java源文件动态编译为.class文件**(动态代理,web开发中)

### 1.7 常用助记符

> * ldc 表示将int,float或是String类型的常量值从常量池中推送到栈顶
> * bipush 表示将单字节(-128~127)的常量值推送到栈顶
> * sipush 表示将一个短整型常量值(-32768~32767)推送到栈顶
> * iconst_1 表示将int类型的1推送到栈顶 (iconst_-1 ~ iconst_5)
> * anewarray 表示创建一个引用类型的(如类，接口，数组)数组，并将其引用值压入栈顶
> * newarray  表示创建一个指定的原生类型的数组，并将其引用值压入栈顶

### 1.8 类加载过程 

> **类的加载的最终产品是位于内存中的Class对象**
>
> Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口

![初始化](C:\Users\Administrator\Desktop\JVM\images\初始化.jpg)

![过程](C:\Users\Administrator\Desktop\JVM\images\过程.JPG)

### 1.9 类加载器

> **类加载器并不需要等到某个类被"首次主动使用"时再加载它。**
>
> JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，**类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误).**
> **如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误**
>
> 有两种类型的类加载器：
>
> + Java虚拟机自带的加载器
>   + 根类加载器(Bootstrap)
>   + 扩展类加载器(Extension)
>   + 系统（应用）类加载器(System)
> + 用户自定义的类加载器
>   + java.lang.ClassLoader的子类
>   + 用户可以定制类的加载方式

### 1.10 类的验证

> 类被加载后，就进入了连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
>
> 类的验证内容：
>
> + 类文件的结构检查
> + 语义检查
> + 字节码验证
> + 二进制兼容性的验证

### 1.11 类的初始化

> **当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。**
> 在初始化一个类时，并不会先初始化它所实现的接口
> 在初始化一个接口时，并不会先初始化它的父接口
> 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。**只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化**
>
> 类的初始化步骤：
>
> + 假如这个类还没有被加载和连接，那就先进行加载和连接
> + 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
> + 假如类中存在初始化语句，那就依次执行这些初始化语句

### 1.12 类的初始化时机

> 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。
>
> 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

### 1.13 类加载器加载类的规则

> * 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
> * 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
> * 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效
>   
>
> 从JDK1.2版本开始，类的加载过程采用**父亲委托机制**。这种机制能更好的保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载 Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。

### 1.14 JVM内置类加载器

![加载](C:\Users\Administrator\Desktop\笔记\JVM\images\加载.jpg)

> 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。
>
> **站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：** 
>
> + 根(bootstrap)类加载器：**该加载器没有父加载器。它负责加载虚拟机的核心类库**，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库，例如根类加载器会加载$JAVA_HOME中jre/lib/rt.jar里所有的class。根类加载器的实现依赖于底层操作系统，由C++实现，属于虚拟机实现的一部分，它并没有继承java.lang.ClassLoader类。
> + 扩展(Extension)类加载器：**它的父加载器为根类加载器。负责加载Java平台中扩展功能的一些jar包**。它从java.ext.dirs系统属性所指定目录中加载类库，或者从JDK的安装目录jre\lib\ext子目录(扩展目录)下加载类库，如果把用户创建的JAR文件放在这个目录下，也会由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。
> + 系统(System)类加载器：也称为**应用类加载器。它的父加载器为扩展类加载器。它从classpath环境变量或java.class.path所指定的目录中加载类**，它是用户自定义类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。
>
> 除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类 java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类。

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.png)

### 1.15 类加载器的父亲委托机制

> 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，**除了根类加载器之外，其余的类加载器都有全只有一个父加载器**。

![加载过程](C:\Users\Administrator\Desktop\JVM\images\加载过程.jpg)

> 若有一个类加载器成功加载Test类，那么这个类加载器被称为**定义类加载器**，所有能成功返回Class 对象引用的类加载(包括定义类加载器)都被称为**初始类加载器**。

### 1.16 获得ClassLoader的途径

> 调用ClassLoader类的方法，加载一个类并不是对类的主动使用，不会导致类的初始化 只有通过反射Class.forName()才会导致对类的主动使用。

>**获得当前类的ClassLoader**:
>`clazz.getClassLoader()`
>
>
>
>**获得当前线程上下文的ClassLoader**:
>`Thread.currentThread().getContextClassLoader()`
>
>
>
>**获得系统的ClassLoader**:
>`ClassLoader.getSystemClassLoader()`
>
>
>
>**获得调用者的ClassLoader**:
>`DriverManager.getCallerClassLoader()`

### 1.17 自定义类加载器 

> 要创建用户自定义的类加载器，只需要扩展java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，该方法根据参数指定的类的名字，返回对应的Class对象的引用。
>
> 需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载
> 器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.18 命名空间

> **每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。**
> 在同一个命名空间中，不会出现相同的两个类
> 在不同的命名空间中，有可能会出现相同的两个类

### 1.19 类的卸载

> 当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束
> Sample类的生命周期。**一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。**
>
> **由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加载器包括根类加载器，扩展类加载器，和系统类加载器。**Java虚拟机本身会始终引用这些类加载器。而这些类加载器则会始终引用它们所加载的类的Class对象。因此这些Class对象始终是可触及的。
> **由用户自定义的类加载器所加载的类是可以被卸载的。**
>
> 在类加载器的内部实现中，**用一个Java集合来存放所加载类的引用**。另一方面，一个Class对象总是引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表Sample类的Class实例与loader1之间为双向关联关系。
>
> 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

### 1.20 关于命名空间的重要说明

> * 子加载器所加载的类能够访问到父加载器所加载的类
> * 而父加载器所加载的类无法访问子加载器所加载的类

### 1.21 不同类加载器的命名空间关系

> **同一个命名空间内的类是相互可见的**。
>
> **子加载类的命名空间包含所有父加载器的命名空间**。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见根类加载器加载的类。
> **由父加载器加载的类不能看见子加载器加载的类。**
> **如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见**。
>
> **在运行期，一个Java类是由该类的完全限定名(binary name 二进制名)和用于加载该类的定义类加载器(define loader)所共同决定的。**如果同样名字(即相同的完全限定名)的类是由两个不同的加载器所加载，那么这些类就是不同的,相互不可见的即使.class文件的字节码完全一样，并且从相同的位置加载亦如此。

### 1.22 类加载器的双亲委托模型的好处

> * **可以确保Java核心库的类型安全**：所有的Java应用都至少会引用java.lang.Obejct类，也就是说在运行期，java.lang.object这个类会被加载到JVM中，如果这个加载过程是由java应用自己的类加载器所完成
> 的，那么很可能就会在JVM中存在多个版本的java.lang.Object类，而且这些类之间还是不兼容，相互不可见的。(正是命名空间在发挥着作用)。
> 借助于双亲委托机制，Java核心类库中的加载工作都是由启动类加载器来统一完成加载工作，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。
> * **可以确保Java核心类库所提供的类不会被自定义的类所替代。**
> * **不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间**。相同名称的类可以并存在java虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这就是相当于在JVM内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
> * 需要指出的是，**加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。**一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器。

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器3 
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.23 根类加载器说明

> 内键于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，**当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器(Bootstrap).**
> 启动类加载器并不是java类，而其他的加载器则都是Java类，启动类加载器是特定于平台的机器指令，它负责开户整个加载过程，**所有类加载器除了启动类加载器都被实现为Java类。不过，总归要有一个主键来加载第一个Java类加载器，从而让整个加载过程能顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。**启动类加载器还会负责加载JRE正常运行所需要的基本组件，这包括java.util,java.lang.等包中类。

### 1.24 线程上下文类加载器

> 当前类加载器(Current ClassLoader):
>
> 每个类都会使用自己的类加载器(即加载自身的类加载器)来去加载其他类(指的是它所依赖的类)
> 如果ClassX引用了ClassY，那么 ClassX类的加载器就会去加载ClassY，(前提是ClassY尚未被加载)
>
> 线程上下文类加载器 （Context ClassLoader）:
> 线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。 如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，**线程将继承其父线程的上下文类加载器,Java应用运行时的初始线程的上下文类加载器是系统类加载器(AppClassLoader)，在线程中运行的代码可以通过该类加载器来加载类与资源**。

### 1.25 线程上下类加载器的重要性

> SPI(Service Provider Interface):服务提供者接口
> **父ClassLoader可以使用当前线程T`hread.currentThread.getContextClassLoader()`所指定的classLoader加载的类**，这就改变了父ClassLoader不能使用子ClassLoader或其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
>
> **线程上下文类加载器就是当前线程的Current ClassLoader**.在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载，但对于SPI来说，有些接口是Java核心库提供的。而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(一般是厂商提供)，而Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。

> **默认的上下文类加载器都是系统类加载器，是在Launcher源码中设置的**

```java
       try {
           //获取到系统类加载器，赋值给loader
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
        //设置当前线程上下文类加载器为 AppClassLoader
        Thread.currentThread().setContextClassLoader(this.loader);
```

### 1.26 线程上下文类加载器的一般使用模式

> * 获取
> * 使用
> * 还原
>
> myMethod()里面则调用了`Thread.currentThread().getContextClassLoader()`获取当前线程的上下文类加载器做某些起事情。
> 如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载(前提该依赖类之前还没有被加载过)**ContextClassLoader的作用就是为了破坏Java的双亲委托机制。**
> **当高层提供了统一的接口让底层去实现，同时又要在高层加载(或实例化)底层的类时，就必须要通过线程上下文 加载器来帮助高层的ClassLoader找到并加载该类。默认线程上下文类加载器就是应用类加**
> **载器(AppClassLoader)**

```java
    //获取AppClassLoader
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    try{
       //使用,  targetTccl: 你想要使用的类加载器
       Thread.currentThread().setContextClassLoader(targetTccl);
       myMethod();
     }
     finally {
       //还原成原来的 AppClassLoader
       Thread.currentThread().setContextClassLoader(classLoader)
     }
```

### 1.27 Class.forNmae() 与 ClassLoader.loadClass()区别

> * Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
> * ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
> * Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

### 1.28 双亲委派模型

> 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
>
> 双亲委派机制:
>
> 1、当`AppClassLoader`加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器`ExtClassLoader`去完成。
>
> 2、当`ExtClassLoader`加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给`BootStrapClassLoader`“`去完成。
>
> 3、如果`BootStrapClassLoader`加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用`ExtClassLoader`来尝试加载；
>
> 4、若`ExtClassLoader`也加载失败，则会使用`AppClassLoader`来加载，如果`AppClassLoader`也加载失败，则会报出异常`ClassNotFoundException`。 

## 2. 字节码文件结构

> * 使用javap -verbose命令分析一个字形码文件时，将会分析该**字形码的魔数，版本号，常量池，类信息，类的构造方法，类中方法信息，类变量与成员变量等信息。**
> * 魔数：所有的.class字形码文件的前4个字节都是魔数，**魔数值为固定值：0xCA FE BA BE(咖啡宝贝)**
> * 魔数之后的4个字节为版本信息，**前两个字节表示minor version(次版本号)，后两个字节为表示major version(主版本号).**例如 00 00 0034,换算成十进制，表示次版本号为：0，主版本号为：52。所以，该文件的版本为：1.8.0.可以通过java -version命令来验证。
> * 常量池(constant pool)：紧接着主版本号之后的就是常量池入口。一个Java类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是 Class文件的资源仓库。比如说：Java类中定义的方法与变量
>   信息，都是存储在常量池中。**常量池中主要存储两类常量：字面量与符号引用。**
>   * **字面量：文本字符串，Java中声明为final的常量值**
>   * **符号引用：类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。**
> * 常量池的总体结构：**Java类所对应的常量池主要由常量池数量与常量池数组(常量表)这两部分共同构成**。**常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。**常量池数组与一般的数组不同的是：常量池数组中不同的元素的类型，结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是一个标志位，占据1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 - 1(其中0暂时不使用)。目的是满足某些常量池索引值的数据在特定情况下需要表达：不引用任何一个常量池的含义；根本原因在于，索引为0也是一个常量(保留常量)，只不过它不位于常量表中，这个常量就对应null值。所以，常量池的索引从1而非0开始。

### 2.1 什么是Class文件

> Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。
>
> Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。
>
> class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。

### 2.2 Class文件结构

> 为了便于理解，我将一个完整的表划分为以下七个部分，这七个部分组成了一个完整的 Class 字节码文件：
>
> - 魔数(CAFEBABE)与Class文件版本(次版本号和主版本号)
> - 常量池(constant_pool)
> - 访问标志
> - 类索引、父类索引、接口索引
> - 字段表集合
> - 方法表集合
> - 属性表集合
>
> 在JVM规范中，每个变量/字段都有描述信息，描述信息主要是描述字段的数据类型，方法的参数列表(包括数量，类型与顺序)与返回值。
> 根据描述符规则，**基本数据类型和代表无返回值的void类型都是用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。**
>
> 对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录 [ L
>
> `String[][]` 被记录为 [ [ Ljava/lang/String;
>
> 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组 () 之内，如方法:`StringgetRealNamyById(int id,String name)`的描述符为:
> **(I,Ljava/lang/String;) Ljava/lang/String;**
>
> 为了压缩字节码文件的体积 。对于基本数据类型，JVM都只使用一个大写字母表示，如下所示

`B - byte ,C - char ,D - double,F - float,I - int,J - long,S - short,Z -boolean,V -void,L - 对象类（Ljava/lang/String;）`

![class](C:\Users\Administrator\Desktop\笔记\JVM\images\class.JPG)

### 2.3 魔术与Class文件

> Class 文件的第 1 - 4 个字节代表了该文件的魔数（Magic  Number）。**它唯一的作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件**，其值固定是：0xCAFEBABE（咖啡宝贝）。如果一个  Class 文件的魔数不是 0xCAFEBABE，那么虚拟机将拒绝运行这个文件。
>
> Class 文件的第 5 - 6 个字节代表了 Class 文件的次版本号（Minor Version），即编译该 Class 文件的 JDK 次版本号。
>
> Class 文件的第 7 - 8 个字节代表了 Class 文件的主版本号（Major Version），即编译该 Class 文件的 JDK 主版本号。
>
> 高版本的 JDK 能向下兼容以前笨笨的 Class 文件，但不能运行新版本的 Class 文件。例如一个 Class 文件是使用 JDK  1.5 编译的，那么我们可以用 JDK 1.7 虚拟机运行它，但不能用 JDK 1.4 虚拟机运行它。

### 2.4 常量池

>  紧跟版本信息之后的是常量池信息，其中前 2 个字节表示常量池个数，其后的不定长数据则表示常量池的具体信息。 

### 2.5 访问标记

>  这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型等。具体的标志位以及标志的含义见下表。 
>
> 假如这两个字节是 00 21，通过查看我们并没有发现有标志值是 00 21 的标志名称。这是因为这里的访问标志可能是由多个标志名称组成的，所以字节码文件中的标志值其实是多个值进行或运算的结果。
>
> 通过查阅上述表格，我们可以知道，00 21 由 00 01（第1行）和 00 20（第3行）进行或运算得来。也就是说该类的访问标志是 public 并且允许使用 invokespecial 字节码指令的新语义。

![访问](C:\Users\Administrator\Desktop\笔记\JVM\images\访问.JPG)

### 2.6 类索引，父类索引，接口索引

> 在访问标记后，则是类索引、父类索引、接口索引的数据，这里数据为：00 05 00 06 00 00。
>
> 类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。

![索引](C:\Users\Administrator\Desktop\笔记\JVM\images\索引.JPG)

> * **类索引**:类索引用于确定这个类的全限定名，它用一个 u2 类型的数据表示。这里的类索引是 00 05 表示其指向了常量池中第 5 个常量，通过我们之前的分析，我们知道第 5 个常量其最终的信息是 Demo 类。
>
> * **父类索引**:父类索引用于确定这个类的父类的全限定名，父类索引用一个u2类型的数据表示。这里的父类索引是  00 06 表示其指向了常量池中第 6 个常量，通过我们之前的分析，我们知道第 6 个常量其最终的信息是 Object  类。因为其并没有继承任何类，所以 Demo 类的父类就是默认的 Object 类。
>
> * **接口索引**:接口索引集合就用来描述哪个类实现了哪些接口，这些被实现的接口将按 implements  语句（如果这个类本身就是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。对于接口索引集合，入口第一项是 u2  类型的数据为接口计数器（interfaces_count），表示索引表的容量，而在接口计数器后则紧跟着所有的接口信息。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。
>
> 这里 Demo 类的字节码文件中，因为并没有实现任何接口，所以紧跟着父类索引后的两个字节是0x0000，这表示该类没有实现任何接口。因此后面的接口索引表为空。

### 2.7 方法中Code结构

> * a):attribute_length:表示attribute所包含的字节数，不包含attribute_name_index和attribute_length字段（方法中所对应的代码的指令）
> * b):max_stack:表示这个方法运行的任何时刻所能达到的操作数栈的最大深度
> * c):max_locals:表示方法执行期间创建的局部变量的数目，包含用来表示传入参数的局部变量。
> * d):code_length:表示该方法所包含的字节码的字节数以及具体的指令码，具体字节码即是该方法被调用时，虚拟机所执行的字节码。
> * f):exception_table:这是存放的是处理异常的信息
> * g):每个exceptin_table表项由start_pc,end_pc,handler_pc,catch_type组成
>
> * `exception_table`:这里存放的是处理异常的信息，**每个exception_table表项由**
>   **start_pc,end_pc,handler_pc ,catch_type组成。**
>   * start_pc 和 end_pc表示在code数组中的从start_pc到end_pc处
>     （包含start_pc，不包含end_pc）的指令抛出异常会由这个表项
>     （handler_pc）来处理。
>   * handler_pc表示处理异常的代码的开始处。catch_type表示会被处
>     理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，
>     表示处理所有的异常。

#### 2.7.1 附加属性

> 接下来是该方法的附加属性，`LineNumberTable`:这个属性用来表示 code数组中字节码和Java代码行数之间的关系 。**这个属性可以用来在调试的时候定位代码执行的行数。**

#### 2.7.2 字节码中的this

> * 对于Java中非静态方法（非static方法，一个实例方法）来说，它至少会有一个局部变量，就是 this。在字节码中 this是作为方法的第一个参数隐式的传进来的。在编译器隐式传进来的，所以每一个实例方法中都是可以访问 this，放置在方法的第一个参数上。在**编译期就将 this放置每一个非静态方法中的局部变量第一个位置上**。
> * 对于Java类听每一个实例方法（非static方法），其在编译后所生成的字节码当中，**方法参数的数量总是会比源代码中方法参数的数量多一个（this），它位于方法的第一个参数位置处；这样，我们就可以在**
>   **java的实例方法中使用this来去访问当前对象的属性以及其他方法**。这个操作是在编译期间完成的，即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问，接下来的运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。

#### 2.7.3 字节码中的构造方法

> 在一个java类中的 **成员属性(非static类型)的赋值是在类的默认构造方法中实现**(通过类生成class字节码文件可以得到)，如果一个类有多个构造方法，则每个构造方法都会先对成员属性赋值，再执行自己相应的代码。

#### 2.7.4 字节码中的静态变量

> java类中的静态成员变量(static类型)，以及定义的静态代码块中的内容，都会统一的在一个叫 **CLinit()**方法中去执行（通过class字节码文件可得到）

#### 2.7.5 字节码中的try/catch/finally

> **java字节码对于异常的处理方式：**
>
> * 统一采用异常表的方式来对异常进行处理
> * 在jdk 1.4.2之前的版本中，并不是采用异常表的方式来对异常进行处理的。而是采用特定的指令方式。
> * 当异常处理存在finally语句块时，现代化的JVM采取的处理方式是**将finally语句块的字节码拼接到每一个catch块后面，换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码，再通过goto 语句到 return 语句返回，结束方法执行。**
> * 从源代码中看在多个catch块后面只会有一个finally语句块，而从编译后的字节码来看，在每个catch块后面都会有一个finally语句块。

### 2.8 栈帧(stack frame)

> **栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构**。
> 栈帧本身是一和数据结构，封闭了方法的**局部变量表，动态链接信息，方法的返回地址以及操作数栈**等信息。
> 符号引用：
> 直接引用：
>
> * 有些符号引用是在类加载阶段或是第一次使用时就会转换为直接引用，这种转换叫做静态解析；
>
> * 另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这体现为Java的多态性。

### 2.9 字节码中常用的调用方法的指令

> * `invokeinterface`:调用接口中的方法，实际上是在运行期间决定的，决定到底调用实现该接口的哪个对象的特定方法。
> *  `invokestatic`:调用静态方法
> * `invokespecial`:调用自己的私有方法，构造方法(<init>),以及父类的方法。
> * `invokevirtual`:调用虚方法，运行期动态查找的过程。
> * `invokeDynamic`:动态调用方法。

### 2.10 静态解析的4种情形

> **在解析阶段将符号引用转换为直接引用**
>
> * 静态方法
>
> * 父类方法
>
> * 构造方法
>
> * 私有方法(无法重写)
>
>   **以上4类方法称作为非虚方法，他们是在类加载阶段就可以将符号引用转换为直接引用的。**

### 2.11 静态分派

> 方法的重载，对于JVM来说，是一种静态的行为,编译期间就可以确定了

```java
/**
     方法的静态分派：
     Grandpa g1 = new Father();
     以上代码:g1的静态类型 Grandpa，而g1的实际类型（真正指向的类型）
     是Father.
     我们可以得到这样一个结论：变量的静态类型是不会发生变化的。
     而变量的实际类型则
     是可以发生变化的（多态的一种体现）。实际类型是在运行期间方可确定。
 */
public class MyTest3 {

    public void test(Grandap grandap){
        System.out.println("grandpa");
    }

    public void test(Father father){
        System.out.println("father");
    }

    public void test(Son son){
        System.out.println("son");
    }
    /**
   方法的重载，对于JVM来说，是一种静态的行为,编译期间就可以确定了
   对于g1,g2来说，他们的静态行为是 Grandpa,
    所以会调用参数是 Grandpa 类型的方法
    */
    public static void main(String[] args) {

        Grandap g1 = new Father();
        Grandap g2 = new Son();

        MyTest3 test3 = new MyTest3();
        test3.test(g1);
        test3.test(g2);
        /*
         输出结果：
         grandpa
         grandpa
        */
    }
}

class Grandap {

}

class Father extends Grandap {

}

class Son extends Father {

}
```

### 2.12 动态分派

```java
     /*
         方法的动态分派：
         方法的动态分派涉及到一个重要概念：方法接收者。
         invokevirtual字节码指令的多态查找流程
         1)：找到操作数栈顶的第一个元素（引用），它所指向对象的实际类型
         2）：如果在常量池中找到与方法描述符，和方法名称一样的情况下
         并且访问权限也通过的话
         3) ：将符号引用转换为找到实例的直接引用，并调用该方法
         4）：如果没有找到，则根据继承体系，从下往上找，直到找到，没有则抛出异
        常
         比较方法重载（overload）和方法重写（override），我们可以得到结论：
         方法重载是静态的，是编译期行为，方法重写是动态的，是运行期行为。
      */

public class MyTest4 {

    public static void main(String[] args) {

        Fruit apple = new Apple();
        Fruit orange = new Orange();

        apple.test();
        orange.test();
        /**
         * 运行结果
         *Apple
         * orange
         */
    }
}
class Fruit {
    public void test(){
        System.out.println("Fruit");
    }
}
class Apple extends Fruit {
    @Override
    public void test() {
        System.out.println("Apple");
    }
}
class Orange extends Fruit {
    @Override
    public void test() {
        System.out.println("orange");
    }
}
```

### 2.13 基于栈的指令集与寄存器指令集的区别

> 现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。
>
> * 所谓解释执行，就是通过解释器来读取字节码遇到相应的指令就去执行该指令。
> * 编译执行，是通过即时编译器（Just in time，JIT）将字节码转换为本地机器码来执行。现代JVM会根据代码热点（使用频率高的代码）来生成相应本地机器码。
>
> * JVM执行指令时所采取的方式是基于栈的指令集
> * 基于栈的指令集主要的是操作有入栈与出栈两种
> * 基于栈的指令集的优势在于它可以在不同的平台之间移植，而基于寄存器的指令集与硬件架构紧密关联的，无法做到可移植。
> *  基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多
>   基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行，它是在高速缓冲区中执行的，速度要快很多，虽然虚拟机可以采用一些优化手段，但总的来说，基于栈的指令集的执行要慢一些。

