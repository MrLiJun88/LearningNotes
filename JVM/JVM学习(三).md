# JVM学习(三)

## 1. 垃圾回收

### 1.1. JVM运行时数据区域

> * 程序计数器
> * 本地方法栈
> * Java虚拟机栈
>   * **Java虚拟机栈描述的是Java方法的执行模型**：每个方法执行的时候都会创建一个帧(Frame)栈用于存放**局部变量表，操作数栈，动态链接，方法出口**等信息。**一个方法的执行过程，就是这个方法对于栈帧的入栈和出栈过程。**
>   * JVM栈是线程私有的
> * 堆
>   * **堆里存放的是对象的实例**
>   * 是Java虚拟机管理内存的最大一块
>   * GC主要的工作区域，为了高效的GC，会把堆细分更多的子区域
>   * 线程共享
> * 方法区域
>   * **存放了每个Class的结构信息，包括常量池，字段描述，方法描述**
>   * GC的非主要工作区域
>
> ```java
> public void method(){
>     Object obj = new Object();
> }
> ```
>
> * 上述的例子中，生成了两个部分的内存区域
>   1. `obj` 这个引用变量，因为是方法内的变量，放在JVM栈中
>   2. 真正`Object class`的实例对象，放到Heap中
> * `new` 语句一共消耗12个bytes,JVM规定引用占4个bytes(在JVM Stack)，而空对象是8个bytes(在Heap)
> * **方法结束后，对应的Stack中变量马上回收，但是Heap中的对象要等到GC来回收。**

### 1.2 JVM垃圾回收(GC)模型

> * 垃圾判断算法
> * GC算法
> * 垃圾回收器的实现与选择

### 1.3 垃圾判断的算法

> * **引用计数算法(Reference Counting)**
>
>   1. 给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效，计数器减1，任何时刻计数器为0的对象就不可能再被使用的。
>
>      2.引用计数算法无法解决对象循环引用的问题(即：有两个孤立的对象互相引用，此时两个对象的计数器值都为1，就不会被垃圾回收)。
>
> * **根搜索算法(Root Tracing)**
>
>   1. 在实际的生产语言中(Java,C#等)，都是使用根搜索算法判定对象是否存活。
>   2. 算法基本思想就是**通过一系列的称为"GC Roots"的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链(Reference Chain)相连，则证明此对象是不可用的**。
>   3. 在Java语言中，GC Roots包括
>      * 在VM栈(帧中的本地变量)中的引用
>      * 方法区中的静态引用
>      * JNI(即一般说的是Native方法)中的引用

### 1.4 方法区的垃圾回收

> * Java虚拟机规范表示可以不要求虚拟机在这区实现GC，这区GC的"性价比"一般比较低。
> * 在堆中，尤其是在新生代，常规应用进行一次GC一般只可以回收70%~95%的空间，而方法区的GC效率远小于此。
> * 当前的商业JVM都有实现方法区的GC，主要回收两部分内容：**废弃常量与无用类。**
> * **类回收需要满足如下3个条件**
>   1. 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。
>   2. 加载该类的ClassLoader已经被GC
>   3. 该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。
> * 在大量使用反射，动态代理，CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要JVM具备类卸载的支持以保证方法区不会溢出。

### 1.5 JVM常见GC算法

> * 标记-清除算法（Mark-Sweep）
> * 标记-整理算法（Mark-Compact）
> * 复制算法（Copying）
> * 分代算法（Generational）

#### 1.5.1 标记-清除算法(Mark-Sweep)

> * 算法分为“**标记**”和“**清除**”两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。
> * 缺点
>   * **效率问题**：标记和清理两个过程效率都不高
>   * **空间问题**：标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作。
> * 效率不高，需要扫描所有对象。堆越大，GC越慢。
> * 存在内存碎片问题。GC次数越多，碎片越严重。

#### 1.5.2 复制搜集算法(Copying)

> * **将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面**，然后就把原来整块内存空间一次性清理掉。
> * 这样使得每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。
> * **这种算法的代价是将内存缩小为原来的一半，代价高昂。**
> * 现在的商业虚拟机中都是用了这一种收集算法来回收**新生代**。
> * 将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块 from survivor，**当回收时将eden和 from survivor中还存活的对象一次性拷贝到另外一块to survivor空间上，然后清理掉eden和用过的from survivor。**
> * **Oracle Hotspot虚拟机默认eden和survivor的大小比例是8：1，也就是每次只有10%的内存是“浪费”的**。
> * **复制收集算法在对象存活率高的时候，效率有所下降。**
> * 如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况，**所以在老年代一般不能直接选用这种算法**。
> * 只需要扫描存活的对象，效率更高。
> * **不会产生碎片**
> * **需要浪费额外的内存作为复制区**
> * **复制算法非常适合生命周期比较短的对象**，因为每次GG总能回收大部分的对象，复制的开销比较小。
> * 根据IBM的专门研究，98%的Java对象只会存活一个GC周期，对这些对象很适合复制算法。而且不用1：1的划分工作匀和复制区的空间。

#### 1.5.3 标记-整理算法(Mark-compact)

>* **标记过程仍然一样，但后续步骤不理进行直接清理，而是令所有存活的对象向一端移动，然后直接清理掉这端边界以外的内存。**
>* **没有内存碎片**
>* 比Mark-Sweep耗费更多的时间进行整理(compact)上

#### 1.5.4 分代收集算法

> * **当前商业虚拟机的垃圾收集都是采用“分代收集”(Generational Collectioning)算法，根据对象不同的存活周期将内存划分为几块。**
> * **一般是把Java堆分作新生代与老年代**，这样就可以根据各个年代的特点采用最适当的收集算法，譬如新生代每次GC都有大批对象死去，只有少量存活，那就选用**复制收集算法**，只需要付出少量存活对象的复制成本就可以完成收集。
> * 综合前面几种GC算法的优缺点，针对不同生命周期的对象采用不同的GC算法
> * Hotspot JVM6中共划分三个代：年轻代(Young Generation)，老年代(Old Generation)，永久代(Permanent Generation)。

![分代](C:\Users\Administrator\Desktop\笔记\JVM\images\分代.JPG)

##### 1.5.4.1 年轻代(Young Generation)

> * 新生成的对象都放在新生代。**新生代用复制收集算法进行GC**（理论上，新生代对象的生命周期非常短，所以适合复制算法）。
> * **新生代分为三个区。一个Eden区，两个Survivor区**（可以通过参数设置Survivor个数）。对象在Eden区中生成。当Eden区满进，还存活的对象将被复制到一个Survivor区，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。**两个Survivor是完全对象，轮流替换**。Eden和两个Survivor的缺省比例是8：1：1，也就是10%的空间会被浪费。可以根据GC log的信息调整大小的比例。

##### 1.5.4.2 老年代(Old Generation)

> * 存放了经过一次或多次GC还存活的对象。
> * 一般采用Mark-Sweep或者Mark-Compat算法进行GC
> * 有多种垃圾收集器可以选择。每种垃圾收集器可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器(追求吞吐量？追求最短的响应时间?)

##### ~~1.5.4.3 永久代~~

> * **并不属于堆（Heap），但是GC也会涉及到这个区域。**
> * 存放了每个Class的结构信息，包括常量池，字段描述，方法描述。与垃圾收集要收集的Java对象关系不大。

### 1.6 内存分配

> 1. **堆上分配**：大多数情况下在eden上分配，偶尔会直接在old上分配，细节取决于GC的实现。
> 2. **栈上分配**：原子类型的局部变量。

### 1.7 内存回收

> * GC要做的是将那些dead的对象所占用的内存回收掉
>   * **Hotspot认为没有引用的对象是dead的**
>   * Hotspot将引用分为四种：**Strong,Soft,Weak,Phantom**
>     * Strong即默认通过 `Object o = new Object()`这种方式赋值的引用
>     * Soft,Weak,Phantom 这三种则都是继承Reference
> * **在Full GC时会对Reference类型的引用进行特殊处理**
>   * Soft:内存不够进一定会被GC，长期不用也会被GC
>   * Weak:一定会被GC，当被mark为dead，会在ReferenceQueue中通知
>   * Phantom:本来就没有引用，当从 jvm heap中释放时会通知 

### 1.8 GC的时机

> * 在分代模型的基础上，GC从时机上分为两种：**Scavenge GC和Full GC**
>   * Scavenge GC(Minor GC)
>     * **触发时机：新对象生成时，Eden空间满了**
>     * 理论上Eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会很高，Scavenge GC时间比较短
>   * Full GC
>     * **对整个JVM进行整理，包括Young,Old和Perm**
>     * 主要的触发时机
>       1. Old满了
>       2. Perm满了
>       3. System.gc()
>     * **效率很低，尽量减少Full GC。**

### 1.9 垃圾回收器(Garbage Collector)

> * 分代模型：GC的宏观愿景
> * 垃圾回收器：GC的具体实现
> * Hotspot JVM提供多种垃圾回收器，我们需要根据具体应用的需要采取不同的回收器。
> * 没有万能的垃圾回收器，每种垃圾回收器都有自己的适用场景。

### 1.10 垃圾收集器的“并行”和“并发”

> * 并行(Parallel)：指多个收集器的线程同时工作，但是用户线程处于等待状态。
> * 并发(Concurrent)：指收集器在工作的同时，可以允许用户线程工作。
>   * 并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候。但在清除垃圾的时候，用户线程可以和GC线程并且发执行。

#### 1.10.1 Serial收集器

> * **单线程收集器，收集时会暂停所有工作线程**(Stop The World,简称STW),使用复制收集算法，虚拟机运行在Client模式时的默认新生代收集器。
> * 最早的收集器，单线程进行GC
> * New和Old Generation都可以使用
> * **在新生代，采用复制算法；在老年代，采用Mark-Compact算法**
> * 因为是单线程GC，没有多线程切换的额外开销，简单实用
> * Hotspot Client模式缺省的收集器

#### 1.10.2 ParNew收集器

> * **ParNew收集器就是Serial的多线程版本**，除了使用多个收集线程外，其余行为包括算法，STW,对象分配规则，回收策略等都与Serial收集器一模一样。
> * 对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果。
> * 是Serial收集器在新生代的多线程版本
> * **使用复制算法（因为针对新生代）**
> * **只有在多CPU的环境下，效率才会比Serial收集器高**
> * 可以通过 -XX:ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
> * Server模式下新生代的缺省收集器。

#### 1.10.3 Parallel Scavenge收集器

> * Parallel Scavenge收集器也是一个多线程收集器，也是使用**复制算法**，但它的对象分配规则与回收策略都与ParNew收集器有所不同，**它是以吞吐量最大化(即GC时间占总运行时间最小)为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。**

#### 1.10.4 Serial Old收集器

> * Serial Old是单线程收集器，使用标记-整理算法，是老年代的收集器

#### 1.10.5 Parallel Old收集器

> * **老年代版本吞吐量优先收集器，使用多线程和标记-整理算法**，JVM 1.6提供，在此之前，新生代使用PS收集器的话，老年代除Serial Old外别无选择，因为PS无法与CMS收集器配合工作。
> * Parallel Scavenge在老年代的实现
> * 在JVM 1.6才出现Parallel Old
> * 采用多线程，Mark-Compact算法
> * 更注重吞吐量
> * **Parallel Scavenge + Paralled Old = 高吞吐量，但GC停顿可能不理想**。

#### 1.10.6 CMS收集器(Concurrent Mark Sweep)

> * **CMS是一种以最短停顿时间为目标的收集器**，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，**CMS收集器使用的是标记-清除算法**。
> * 追求最短停顿时间，非常适合Web应用
> * **只针对老年区，一般结合ParNew使用**
> * Concurrent，GC线程和用户线程并发工作（尽量并且发）
> * Mark-Sweep算法
> * 只有在多CPU环境下才有意义
> * 使用 `-XX:+UseConcMarkSweepGC`打开
> * **CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大。**
> * **CMS在并发清理的过程中，用户线程还在跑。这时候需要预留一部分空间给用户线程**
> * CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC。

### 1.11 Java内存泄露

> * **内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露**。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。
> *  那么，Java内存泄露根本原因是什么呢？**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

### 1.12 Java内存泄露的经典原因

> * 对象定义在错误的范围
>   *  长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。
> * 异常处理不当
> * 集合数据管理不当
>   * 当使用Array-based的数据结构(`ArrayList,HashMap`等)时，尽量减少resize
>     * 比如 `new ArrayList()`时，尽量估算size，在创建的进修把size确定
>     * 减少resize 可以避免没有必要的array copying,gc碎片等问题。
>   * 如果一个List只需要顺序访问，不需要随机访问(Random Access),用LinkedList代替ArrayList
>     * LinkedList本质是链表，不需要resize,但只适合于顺序访问。

### 1.13 GC时的线程处理

#### 1.13.1 枚举根节点

> 当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。

#### 1.13.2 安全点

> * 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说Oopmap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高。
> * 实际上，HotSpot并没有为每条指令都生成OopMap，而只是在“特定的位置”记录了这些信息，这些位置称为**安全点(Safepoint)**,即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。
> * SafePoint的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载。所以，**安全点的选定基本上是以“是否具有让程序长时间执行特征”为标准进行选定的**，因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，**“长时间执行”的最明显特征就是指令序列复用，例如方法调用 ，循环跳转，异常跳转等，所以具有这些功能的指令才会产生SafePoint。**
> * 对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来：**抢占式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension)。**
>   * 抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。
>   * 主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，**发现中断标志为真时就自己中断挂起。轮询标志的地方和安全是重合的，另外再加上创建对象需要分配内存的地方**。
>   * **现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件。**

#### 1.13.3 安全区域

> * 在使用SafePoint似乎已经完美地解决了如何进行GC的问题，但实际上情况却并一定。SafePoint机制保证了程序执行时，在不太长时间内就会遇到可进入GC的SafePoint。但如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域(Safe Region)来解决了。
> * 在线程执行到Safe Region中的代码时，首先标识自己已经进入了 Safe Region,那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。

### 1.14 CMS垃圾收集器

> * CMS(Concurrent Mark Sweep)收集器，**以获取最短回收停顿时间为目标**，多数应用于互联网站或者B/S系统的服务器端上。
> * CMS是基于“**标记-----清除**”算法实现的，整个过程分为4个步骤
>   1. 初始标记(CMS initial mark)
>   2. 并发标记(CMS concurrent mark)
>   3. 重新标记(CMS remark)
>   4. 并发清除(CMS concurrent sweep)
> * **其中，初始标记，重新标记这两个步骤仍然需要"Stop The World"**
> * 初始标记只是标记一下GC Roots能直接关联到的对象，速度很快
> * 并发标记阶段就是进行GC Roots Tracing的过程
> * **重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并且发标记的时间短。
> * CMS收集器在整个过程中耗时最长的**并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的。**
> * 优点
>   * 并发收集，低停顿，Oracle公司的一些官方文档中也称之为**并发低停顿收集器**(Concurrent Low Pause Collector)
> * 缺点
>   * **CMS收集器对cpu资源非常敏感**
>   * CMS收集器无法处理**浮动垃圾（Floating Garbage）**，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。如果在应用中老年代增长不是太快，可以适当调高参数 -XX:CMSInitationOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。**要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。**所以说参数 -XX:CMSInitatingOccupancyFraction设置得太高很容易导致大量"Concurrent Mode Failure"失败，性能反而降低。
>   * **收集结束时会有大量空间碎片产生**，空间碎片过多时，将会给大量对象分配带来很大麻烦，**往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次Full GC。**CMS收集器提供了一个 -XX:+UseCMSCompactAtFullConllection 开关参数（默认就是开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。

#### 1.14.1 空间分配担保

> * 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，而Survivor空间又不足以存放时，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象空间的平均值为作经验值），则进行一次Full GC。

#### 1.14.2 CMS收集器收集步骤

![cms](C:\Users\Administrator\Desktop\笔记\JVM\images\cms.JPG)

> 1. Inital Mark
>
>    `这个CMS两次 stop-the-world事件的其中一次，这个阶段的目标是：标记那些直接被GC Root引用或者被年轻代存活对象所引用的所有老年代的对象。`
>
> 2. Concurrent Mark
>
>    `在这个阶段Garbage Collector会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到的GC Roots遍历查找。并发标记阶段，它会与用户的应用程序并发运行。并且不是老年代所有的存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用。`
>
> 3. Concurrent Preclean(并发预先清理)
>
>    `这也是一个并发阶段，与应用的线程并且发运行，并不会停止应用的线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM会将包含这个对象的区域(Card)标记为Dirty，这也就是 Card Marking`
>
>    `在pre-clean阶段，那些能够从Dirty对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了.`
>
> 4. Concurrent Abortable Preclean(并发可失败的预先清理)
>
>    `这也是一个并发阶段，但是同样不会影响用户的应用线程，这个阶段是为了尽量承担STW(stop-the-world)中最终标记阶段的工作。这个阶段持续时间依赖于很多的因素，由于这个阶段是在重复做很多相同的工作，直接满足一些条件(比如：重复迭代的次数、完成的工作量或者时钟时间等)`
>
> 5. Final Remark
>
>    `这是第二个STW阶段，也是CMS中的最后一个，这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，GC线程可能跟不上应用程序的变化，为了完成标记老年代所有存活对象的目标，STW就非常有必要了。`
>
>    `通过CMS的Final Remark阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续STW发生的可能性(年轻代存活对象过多的话，也会导致老年代涉及的存活对象会很多)。这个阶段会比前面的几个阶段量多复杂一些。`
>
>    `经历过这五个阶段之后，老年代所有存活的对象都被标记过了，现在可以通过清除算法去清理那些老年代不再使用的对象`
>
> 6. Concurrent Sweep 
>
>    `这里不需要STW，它是与用户的应用程序并发运行，这个阶段是：清除那些不再使用的对象，回收它们的占用空间为将来使用。`
>
> 7. Concurrent Reset
>
>    `这个阶段也是并发执行的，它会重设CMS内部的数据结构，为下次的GC做准备。`

#### 1.14.3 CMS总结

> * CMS通过将大量工作分散到并发处理阶段来减少STW时间，在这块做得非常优秀，但是CMS也有一些其他的问题。
> * **CMS收集器无法处理浮动垃圾(垃圾回收器认为是存活的，但实际上已经是垃圾了，这是因为CMS标记过程是与用户应用程序是并发执行的)**，可能出现“Concurrent Mode Failure”失败而导致另一次FUll GC的产生，可能引发串行Full GC。
> * **空间碎片，导致无法分配大对象**，CMS收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数(默认就是开启的)，用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长
> * **对于堆比较大的应用，GC的时间难以预估**

### 1.15 系统衡量指标

#### 1.15.1 吞吐量

> * 吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量
> * 如下方式来衡量一个系统吞吐量的好坏
>   * 在一个小时内同一个事务（或者任务、请求）完成的次数(tps)
>   * 数据库一小时可以完成多少次查询
> * 对于关注吞吐量的系统，卡顿(STW)是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑。

#### 1.15.2 响应能力

> * 响应能力指一个程序或者系统对请求是否能够及时响应，比如：
>   * 一个桌面UI能多快地响应一个事件
>   * 一个网站能够多快返回一个页面请求
>   * 数据库能够多快返回查询的数据
> * 对于这类对响应能力第三的场景，长时间的停顿是无法接受的。

### 1.16 G1 (Garbage First)垃圾收集器

> * **G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统**
> * 它满足短时间gc停顿的同时达到一个较高的吞吐量
> * JDK7以上版本适合

#### 1.16.1 G1收集器的设计目标

> * 与应用线程同时工作，几乎不需要 stop the world(与CMS类似)
> * 整理剩余空间，不产生内存碎片(CMS只能在Full GC时，用stop the world整理内存碎片)
> * GC停顿更加可控
> * 不牺牲系统吞吐量
> * GC不要求额外的内存空间(CMS需要预留空间存储**浮动垃圾**)

#### 1.16.2 G1的设计规划是要替换掉CMS

> * G1在某些方面弥补了CMS的不足，比如，CMS使用的是 **mark-sweep**算法，自然会产生内存碎片，然而G1基于**copying**算法，高效的整理剩余内存，而不需要管理内存碎片。
> * 另外，G1提供了更多手段，以达到对GC停顿时间的可控。

#### 1.16.3 G1收集器堆结构

> * **heap被划分一个个相等的不连续的内存区域(**regions),每个region都有一个分代的角色：eden,survivor,old
> * **对每个角色的数量并没有强制的限定**，也就是说对每种分代内存的大小，可以动态变化
> * **G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域(region)**

90