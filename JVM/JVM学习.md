# JVM学习

## 1.类加载器机制

### 1.1 类加载

> 在Java代码中，类的加载，连接与初始化过程都是在**程序运行期间**完成的。
>
> 提供了更大的灵活性，增加了更多的可能性。

### 1.2 Java虚拟机与程序的生命周期

> 在如下几种情况下，Java虚拟机将结束生命周期
>
> * 执行了System.exit()方法
> * 程序正常执行结束
> * 程序在执行过程中遇到了异常或错误而异常终止
> * 由于操作系统出现操作而导致Java虚拟机进程终止

### 1.3 类的加载，连接与初始化

> * 加载：查找并加载类的二进制数据
> * 连接
>       * 验证：确保被加载类的正确性
>       * 准备：为类的**静态变量**分配内存，并将其**初始化为默认值**
>       * 解析：把类的符号引用转换为直接引用
> * 初始化：**为类的静态变量赋予正确的初始化**
> * 使用
> * 卸载

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.jpg)

> Java程序对类的使用方式可分为两种
>
> * 主动使用
> * 被动使用
>
> 所有的Java虚拟机实现必须在每个类或接口被Java程序"**首次主动使用**"时才初始化它们。

### 1.4 类的主动使用(七种)

> * 创建类的实例(new)
> * 访问某个类或接口的静态变量，或者对该静态变量赋值
> * 调用类的静态方法
> * 反射（如Class.forName("com.test.Test")）
> * 初始化一个类的子类
> * Java虚拟机启动时被标明为启动类的类(包含有main()的类)
> * JDK1.7开始提供的动态语言支持(java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化)
>
> 除了以上七种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都**不会导致类的初始化**

### 1.5 类的加载含义

> **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象**（规范并未说明Class 对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封闭类在方法区内的数据结构。

### 1.6 加载.class文件的方式

> * 从本地系统中直接加载
> * 通过网络下载.class文件
> * 从zip,jar等归档文件中加载.class 文件
> * 从专有数据库中提取.class 文件
> * **将Java源文件动态编译为.class文件**(动态代理,web开发中)

### 1.7 常用助记符

> * ldc 表示将int,float或是String类型的常量值从常量池中推送到栈顶
> * bipush 表示将单字节(-128~127)的常量值推送到栈顶
> * sipush 表示将一个短整型常量值(-32768~32767)推送到栈顶
> * iconst_1 表示将int类型的1推送到栈顶 (iconst_-1 ~ iconst_5)
> * anewarray 表示创建一个引用类型的(如类，接口，数组)数组，并将其引用值压入栈顶
> * newarray  表示创建一个指定的原生类型的数组，并将其引用值压入栈顶

### 1.8 类加载过程 

> **类的加载的最终产品是位于内存中的Class对象**
>
> Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口

![初始化](C:\Users\Administrator\Desktop\JVM\images\初始化.jpg)

![过程](C:\Users\Administrator\Desktop\JVM\images\过程.JPG)

### 1.9 类加载器

> **类加载器并不需要等到某个类被"首次主动使用"时再加载它。**
>
> JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，**类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误).**
> **如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误**
>
> 有两种类型的类加载器：
>
> + Java虚拟机自带的加载器
>   + 根类加载器(Bootstrap)
>   + 扩展类加载器(Extension)
>   + 系统（应用）类加载器(System)
> + 用户自定义的类加载器
>   + java.lang.ClassLoader的子类
>   + 用户可以定制类的加载方式

### 1.10 类的验证

> 类被加载后，就进入了连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
>
> 类的验证内容：
>
> + 类文件的结构检查
> + 语义检查
> + 字节码验证
> + 二进制兼容性的验证

### 1.11 类的初始化

> **当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。**
> 在初始化一个类时，并不会先初始化它所实现的接口
> 在初始化一个接口时，并不会先初始化它的父接口
> 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。**只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化**
>
> 类的初始化步骤：
>
> + 假如这个类还没有被加载和连接，那就先进行加载和连接
> + 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
> + 假如类中存在初始化语句，那就依次执行这些初始化语句

### 1.12 类的初始化时机

> 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。
>
> 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

### 1.13 类加载器加载类的规则

> 从JDK1.2版本开始，类的加载过程采用**父亲委托机制**。这种机制能更好的保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载 Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。

### 1.14 JVM内置类加载器

> + 根(bootstrap)类加载器：**该加载器没有父加载器。它负责加载虚拟机的核心类库**，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库，例如根类加载器会加载$JAVA_HOME中jre/lib/rt.jar里所有的class。根类加载器的实现依赖于底层操作系统，由C++实现，属于虚拟机实现的一部分，它并没有继承java.lang.ClassLoader类。
> + 扩展(Extension)类加载器：**它的父加载器为根类加载器。负责加载Java平台中扩展功能的一些jar包**。它从java.ext.dirs系统属性所指定目录中加载类库，或者从JDK的安装目录jre\lib\ext子目录(扩展目录)下加载类库，如果把用户创建的JAR文件放在这个目录下，也会由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。
> + 系统(System)类加载器：也称为**应用类加载器。它的父加载器为扩展类加载器。它从classpath环境变量或java.class.path所指定的目录中加载类**，它是用户自定义类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。
>
> 除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类 java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类。

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.png)

### 1.15 类加载器的父亲委托机制

> 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，**除了根类加载器之外，其余的类加载器都有全只有一个父加载器**。

![加载过程](C:\Users\Administrator\Desktop\JVM\images\加载过程.jpg)

> 若有一个类加载器成功加载Test类，那么这个类加载器被称为**定义类加载器**，所有能成功返回Class 对象引用的类加载(包括定义类加载器)都被称为**初始类加载器**。

### 1.16 获得ClassLoader的途径

> 调用ClassLoader类的方法，加载一个类并不是对类的主动使用，不会导致类的初始化 只有通过反射Class.forName()才会导致对类的主动使用。

>**获得当前类的ClassLoader**:
>`clazz.getClassLoader()`
>
>
>
>**获得当前线程上下文的ClassLoader**:
>`Thread.currentThread().getContextClassLoader()`
>
>
>
>**获得系统的ClassLoader**:
>`ClassLoader.getSystemClassLoader()`
>
>
>
>**获得调用者的ClassLoader**:
>`DriverManager.getCallerClassLoader()`

### 1.17 自定义类加载器 

> 要创建用户自定义的类加载器，只需要扩展java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，该方法根据参数指定的类的名字，返回对应的Class对象的引用。
>
> 需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载
> 器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.18 命名空间

> **每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。**
> 在同一个命名空间中，不会出现相同的两个类
> 在不同的命名空间中，有可能会出现相同的两个类

### 1.19 类的卸载

> 当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束
> Sample类的生命周期。**一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。**
>
> **由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加载器包括根类加载器，扩展类加载器，和系统类加载器。**Java虚拟机本身会始终引用这些类加载器。而这些类加载器则会始终引用它们所加载的类的Class对象。因此这些Class对象始终是可触及的。
> **由用户自定义的类加载器所加载的类是可以被卸载的。**
>
> 在类加载器的内部实现中，**用一个Java集合来存放所加载类的引用**。另一方面，一个Class对象总是引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表Sample类的Class实例与loader1之间为双向关联关系。
>
> 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

### 1.20 关于命名空间的重要说明

> * 子加载器所加载的类能够访问到父加载器所加载的类
> * 而父加载器所加载的类无法访问子加载器所加载的类

### 1.21 不同类加载器的命名空间关系

> **同一个命名空间内的类是相互可见的**。
>
> **子加载类的命名空间包含所有父加载器的命名空间**。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见根类加载器加载的类。
> **由父加载器加载的类不能看见子加载器加载的类。**
> **如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见**。
>
> **在运行期，一个Java类是由该类的完全限定名(binary name 二进制名)和用于加载该类的定义类加载器(define loader)所共同决定的。**如果同样名字(即相同的完全限定名)的类是由两个不同的加载器所加载，那么这些类就是不同的,相互不可见的即使.class文件的字节码完全一样，并且从相同的位置加载亦如此。

### 1.22 类加载器的双亲委托模型的好处

> * **可以确保Java核心库的类型安全**：所有的Java应用都至少会引用java.lang.Obejct类，也就是说在运行期，java.lang.object这个类会被加载到JVM中，如果这个加载过程是由java应用自己的类加载器所完成
> 的，那么很可能就会在JVM中存在多个版本的java.lang.Object类，而且这些类之间还是不兼容，相互不可见的。(正是命名空间在发挥着作用)。
> 借助于双亲委托机制，Java核心类库中的加载工作都是由启动类加载器来统一完成加载工作，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。
> * **可以确保Java核心类库所提供的类不会被自定义的类所替代。**
> * **不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间**。相同名称的类可以并存在java虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这就是相当于在JVM内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
> * 需要指出的是，**加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。**一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器。

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器3 
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.23 根类加载器说明

> 内键于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，**当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器(Bootstrap).**
> 启动类加载器并不是java类，而其他的加载器则都是Java类，启动类加载器是特定于平台的机器指令，它负责开户整个加载过程，**所有类加载器除了启动类加载器都被实现为Java类。不过，总归要有一个主键来加载第一个Java类加载器，从而让整个加载过程能顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。**启动类加载器还会负责加载JRE正常运行所需要的基本组件，这包括java.util,java.lang.等包中类。

### 1.24 线程上下文类加载器

> 当前类加载器(Current ClassLoader):
>
> 每个类都会使用自己的类加载器(即加载自身的类加载器)来去加载其他类(指的是它所依赖的类)
> 如果ClassX引用了ClassY，那么 ClassX类的加载器就会去加载ClassY，(前提是ClassY尚未被加载)
>
> 线程上下文类加载器 （Context ClassLoader）:
> 线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。 如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，**线程将继承其父线程的上下文类加载器,Java应用运行时的初始线程的上下文类加载器是系统类加载器(AppClassLoader)，在线程中运行的代码可以通过该类加载器来加载类与资源**。

### 1.25 线程上下类加载器的重要性

> SPI(Service Provider Interface):服务提供者接口
> **父ClassLoader可以使用当前线程T`hread.currentThread.getContextClassLoader()`所指定的classLoader加载的类**，这就改变了父ClassLoader不能使用子ClassLoader或其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
>
> **线程上下文类加载器就是当前线程的Current ClassLoader**.在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载，但对于SPI来说，有些接口是Java核心库提供的。而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(一般是厂商提供)，而Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。

> **默认的上下文类加载器都是系统类加载器，是在Launcher源码中设置的**

```java
       try {
           //获取到系统类加载器，赋值给loader
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
        //设置当前线程上下文类加载器为 AppClassLoader
        Thread.currentThread().setContextClassLoader(this.loader);
```

### 1.26 线程上下文类加载器的一般使用模式

> * 获取
> * 使用
> * 还原
>
> myMethod()里面则调用了`Thread.currentThread().getContextClassLoader()`获取当前线程的上下文类加载器做某些起事情。
> 如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载(前提该依赖类之前还没有被加载过)**ContextClassLoader的作用就是为了破坏Java的双亲委托机制。**
> **当高层提供了统一的接口让底层去实现，同时又要在高层加载(或实例化)底层的类时，就必须要通过线程上下文 加载器来帮助高层的ClassLoader找到并加载该类。默认线程上下文类加载器就是应用类加**
> **载器(AppClassLoader)**

```java
    //获取AppClassLoader
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    try{
       //使用,  targetTccl: 你想要使用的类加载器
       Thread.currentThread().setContextClassLoader(targetTccl);
       myMethod();
     }
     finally {
       //还原成原来的 AppClassLoader
       Thread.currentThread().setContextClassLoader(classLoader)
     }
```

## 2. 字节码文件结构

> * 使用javap -verbose命令分析一个字形码文件时，将会分析该**字形码的魔数，版本号，常量池，类信息，类的构造方法，类中方法信息，类变量与成员变量等信息。**
> * 魔数：所有的.class字形码文件的前4个字节都是魔数，**魔数值为固定值：0xCA FE BA BE(咖啡宝贝)**
> * 魔数之后的4个字节为版本信息，**前两个字节表示minor version(次版本号)，后两个字节为表示major version(主版本号).**例如 00 00 0034,换算成十进制，表示次版本号为：0，主版本号为：52。所以，该文件的版本为：1.8.0.可以通过java -version命令来验证。
> * 常量池(constant pool)：紧接着主版本号之后的就是常量池入口。一个Java类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是 Class文件的资源仓库。比如说：Java类中定义的方法与变量
>   信息，都是存储在常量池中。**常量池中主要存储两类常量：字面量与符号引用。**
>   * **字面量：文本字符串，Java中声明为final的常量值**
>   * **符号引用：类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。**
> * 常量池的总体结构：**Java类所对应的常量池主要由常量池数量与常量池数组(常量表)这两部分共同构成**。**常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。**常量池数组与一般的数组不同的是：常量池数组中不同的元素的类型，结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是一个标志位，占据1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 - 1(其中0暂时不使用)。目的是满足某些常量池索引值的数据在特定情况下需要表达：不引用任何一个常量池的含义；根本原因在于，索引为0也是一个常量(保留常量)，只不过它不位于常量表中，这个常量就对应null值。所以，常量池的索引从1而非0开始。

### 2.1 

> 在JVM规范中，每个变量/字段都有描述信息，描述信息主要是描述字段的数据类型，方法的参数列表(包括数量，类型与顺序)与返回值。
> 根据描述符规则，**基本数据类型和代表无返回值的void类型都是用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。**
>
> 对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录 [ I
>
> `String[][]` 被记录为 [ [ Ljava/lang/String;
>
> 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组 () 之内，如方法:`StringgetRealNamyById(int id,String name)`的描述符为:
> **(I,Ljava/lang/String;) Ljava/lang/String;**
>
> 为了压缩字节码文件的体积 。对于基本数据类型，JVM都只使用一个大写字母表示，如下所示

`B - byte ,C - char ,D - double,F - float,I - int,J - long,S - short,Z -boolean,V -void,L - 对象类（Ljava/lang/String;）`

41