# JVM学习

## 1.类加载器机制

### 1.1 什么是类加载

> **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。**类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
>
> 在Java代码中，类的加载，连接与初始化过程都是在**程序运行期间**完成的。
>
> 提供了更大的灵活性，增加了更多的可能性。

### 1.2 Java虚拟机与程序的生命周期

![生命](C:\Users\Administrator\Desktop\笔记\JVM\images\生命.jpg)

> **其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。**在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
>
> 在如下几种情况下，Java虚拟机将结束生命周期
>
> * 执行了System.exit()方法
> * 程序正常执行结束
> * 程序在执行过程中遇到了异常或错误而异常终止
> * 由于操作系统出现操作而导致Java虚拟机进程终止

### 1.3 类的加载，连接与初始化

> * 加载：查找并加载类的二进制数据
> * 连接
>       * 验证：确保被加载类的正确性
>       * 准备：为类的**静态变量**分配内存，并将其**初始化为默认值**
>       * 解析：把类的符号引用转换为直接引用
> * 初始化：**为类的静态变量赋予正确的初始化**
> * 使用
> * 卸载

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.jpg)

> Java程序对类的使用方式可分为两种
>
> * 主动使用
> * 被动使用
>
> 所有的Java虚拟机实现必须在每个类或接口被Java程序"**首次主动使用**"时才初始化它们。

#### 1.3.1 加载

> 查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
>
> - 通过一个类的全限定名来获取其定义的二进制字节流。  
> - 将这个字节流所代表的静态存储结构(.class文件)转化为方法区的运行时数据结构。  
> - 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口。
>
> 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
>
> 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

#### 1.3.2 连接

> **验证：确保被加载的类的正确性**
>
> 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
>
> * 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
> * 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
> * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
> * 符号引用验证：确保解析动作能正确执行。
>
> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-`Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
>
> **准备：为类的静态变量分配内存，并将其初始化为默认值**
>
> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
>
> * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
>
> * 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
>
> * 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
>
>   假设上面的类变量value被定义为： public static final int value = 3；
>   
>
> 假设一个类变量的定义为：public static int value = 3；
>
> 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的public static指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
>
> **这里还需要注意如下几点：**
>
> - 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
> - **对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，**总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
> - 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
> - 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值
>
> **解析：把类中的符号引用转换为直接引用**
>
> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
>
> 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 1.3.3 初始化

> **初始化:  为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式**：
>
> * 声明类变量是指定初始值
> * 使用静态代码块为类变量指定初始值
>
> JVM初始化步骤
>
> 1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
> 2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
> 3. 假如类中有初始化语句，则系统依次执行这些初始化语句 

### 1.4 类的主动使用(七种)

> * 创建类的实例(new)
> * 访问某个类或接口的静态变量，或者对该静态变量赋值
> * 调用类的静态方法
> * 反射（如Class.forName("com.test.Test")）
> * 初始化一个类的子类
> * Java虚拟机启动时被标明为启动类的类(包含有main()的类)
> * JDK1.7开始提供的动态语言支持(java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化)
>
> 除了以上七种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都**不会导致类的初始化**

### 1.5 类的加载含义

> **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象**（规范并未说明Class 对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封闭类在方法区内的数据结构。

### 1.6 加载.class文件的方式

> * 从本地系统中直接加载
> * 通过网络下载.class文件
> * 从zip,jar等归档文件中加载.class 文件
> * 从专有数据库中提取.class 文件
> * **将Java源文件动态编译为.class文件**(动态代理,web开发中)

### 1.7 常用助记符

> * ldc 表示将int,float或是String类型的常量值从常量池中推送到栈顶
> * bipush 表示将单字节(-128~127)的常量值推送到栈顶
> * sipush 表示将一个短整型常量值(-32768~32767)推送到栈顶
> * iconst_1 表示将int类型的1推送到栈顶 (iconst_-1 ~ iconst_5)
> * anewarray 表示创建一个引用类型的(如类，接口，数组)数组，并将其引用值压入栈顶
> * newarray  表示创建一个指定的原生类型的数组，并将其引用值压入栈顶

### 1.8 类加载过程 

> **类的加载的最终产品是位于内存中的Class对象**
>
> Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口

![初始化](C:\Users\Administrator\Desktop\JVM\images\初始化.jpg)

![过程](C:\Users\Administrator\Desktop\JVM\images\过程.JPG)

### 1.9 类加载器

> **类加载器并不需要等到某个类被"首次主动使用"时再加载它。**
>
> JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，**类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误).**
> **如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误**
>
> 有两种类型的类加载器：
>
> + Java虚拟机自带的加载器
>   + 根类加载器(Bootstrap)
>   + 扩展类加载器(Extension)
>   + 系统（应用）类加载器(System)
> + 用户自定义的类加载器
>   + java.lang.ClassLoader的子类
>   + 用户可以定制类的加载方式

### 1.10 类的验证

> 类被加载后，就进入了连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
>
> 类的验证内容：
>
> + 类文件的结构检查
> + 语义检查
> + 字节码验证
> + 二进制兼容性的验证

### 1.11 类的初始化

> **当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。**
> 在初始化一个类时，并不会先初始化它所实现的接口
> 在初始化一个接口时，并不会先初始化它的父接口
> 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。**只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化**
>
> 类的初始化步骤：
>
> + 假如这个类还没有被加载和连接，那就先进行加载和连接
> + 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
> + 假如类中存在初始化语句，那就依次执行这些初始化语句

### 1.12 类的初始化时机

> 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。
>
> 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

### 1.13 类加载器加载类的规则

> * 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
> * 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
> * 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效
>   
>
> 从JDK1.2版本开始，类的加载过程采用**父亲委托机制**。这种机制能更好的保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载 Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。

### 1.14 JVM内置类加载器

![加载](C:\Users\Administrator\Desktop\笔记\JVM\images\加载.jpg)

> 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。
>
> **站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：** 
>
> + 根(bootstrap)类加载器：**该加载器没有父加载器。它负责加载虚拟机的核心类库**，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库，例如根类加载器会加载$JAVA_HOME中jre/lib/rt.jar里所有的class。根类加载器的实现依赖于底层操作系统，由C++实现，属于虚拟机实现的一部分，它并没有继承java.lang.ClassLoader类。
> + 扩展(Extension)类加载器：**它的父加载器为根类加载器。负责加载Java平台中扩展功能的一些jar包**。它从java.ext.dirs系统属性所指定目录中加载类库，或者从JDK的安装目录jre\lib\ext子目录(扩展目录)下加载类库，如果把用户创建的JAR文件放在这个目录下，也会由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。
> + 系统(System)类加载器：也称为**应用类加载器。它的父加载器为扩展类加载器。它从classpath环境变量或java.class.path所指定的目录中加载类**，它是用户自定义类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。
>
> 除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类 java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类。

![类加载](C:\Users\Administrator\Desktop\JVM\images\类加载.png)

### 1.15 类加载器的父亲委托机制

> 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，**除了根类加载器之外，其余的类加载器都有全只有一个父加载器**。

![加载过程](C:\Users\Administrator\Desktop\JVM\images\加载过程.jpg)

> 若有一个类加载器成功加载Test类，那么这个类加载器被称为**定义类加载器**，所有能成功返回Class 对象引用的类加载(包括定义类加载器)都被称为**初始类加载器**。

### 1.16 获得ClassLoader的途径

> 调用ClassLoader类的方法，加载一个类并不是对类的主动使用，不会导致类的初始化 只有通过反射Class.forName()才会导致对类的主动使用。

>**获得当前类的ClassLoader**:
>`clazz.getClassLoader()`
>
>
>
>**获得当前线程上下文的ClassLoader**:
>`Thread.currentThread().getContextClassLoader()`
>
>
>
>**获得系统的ClassLoader**:
>`ClassLoader.getSystemClassLoader()`
>
>
>
>**获得调用者的ClassLoader**:
>`DriverManager.getCallerClassLoader()`

### 1.17 自定义类加载器 

> 要创建用户自定义的类加载器，只需要扩展java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，该方法根据参数指定的类的名字，返回对应的Class对象的引用。
>
> 需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载
> 器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.18 命名空间

> **每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。**
> 在同一个命名空间中，不会出现相同的两个类
> 在不同的命名空间中，有可能会出现相同的两个类

### 1.19 类的卸载

> 当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束
> Sample类的生命周期。**一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。**
>
> **由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加载器包括根类加载器，扩展类加载器，和系统类加载器。**Java虚拟机本身会始终引用这些类加载器。而这些类加载器则会始终引用它们所加载的类的Class对象。因此这些Class对象始终是可触及的。
> **由用户自定义的类加载器所加载的类是可以被卸载的。**
>
> 在类加载器的内部实现中，**用一个Java集合来存放所加载类的引用**。另一方面，一个Class对象总是引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表Sample类的Class实例与loader1之间为双向关联关系。
>
> 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

### 1.20 关于命名空间的重要说明

> * 子加载器所加载的类能够访问到父加载器所加载的类
> * 而父加载器所加载的类无法访问子加载器所加载的类

### 1.21 不同类加载器的命名空间关系

> **同一个命名空间内的类是相互可见的**。
>
> **子加载类的命名空间包含所有父加载器的命名空间**。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见根类加载器加载的类。
> **由父加载器加载的类不能看见子加载器加载的类。**
> **如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见**。
>
> **在运行期，一个Java类是由该类的完全限定名(binary name 二进制名)和用于加载该类的定义类加载器(define loader)所共同决定的。**如果同样名字(即相同的完全限定名)的类是由两个不同的加载器所加载，那么这些类就是不同的,相互不可见的即使.class文件的字节码完全一样，并且从相同的位置加载亦如此。

### 1.22 类加载器的双亲委托模型的好处

> * **可以确保Java核心库的类型安全**：所有的Java应用都至少会引用java.lang.Obejct类，也就是说在运行期，java.lang.object这个类会被加载到JVM中，如果这个加载过程是由java应用自己的类加载器所完成
> 的，那么很可能就会在JVM中存在多个版本的java.lang.Object类，而且这些类之间还是不兼容，相互不可见的。(正是命名空间在发挥着作用)。
> 借助于双亲委托机制，Java核心类库中的加载工作都是由启动类加载器来统一完成加载工作，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。
> * **可以确保Java核心类库所提供的类不会被自定义的类所替代。**
> * **不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间**。相同名称的类可以并存在java虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这就是相当于在JVM内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
> * 需要指出的是，**加载器之间的父子关系实际上指的是加载器对象之间的包含关系，而不是类之间的继承关系。**一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器对象中包装了一个父加载器对象。例如以下loader1和loader2 都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器。

```java
 ClassLoader loader1 = new ClassLoader();
 //参数loader1将作为loader2的父加载器3 
 ClaaLoader loader2 = new ClassLoader(loader1);
```

### 1.23 根类加载器说明

> 内键于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，**当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器(Bootstrap).**
> 启动类加载器并不是java类，而其他的加载器则都是Java类，启动类加载器是特定于平台的机器指令，它负责开户整个加载过程，**所有类加载器除了启动类加载器都被实现为Java类。不过，总归要有一个主键来加载第一个Java类加载器，从而让整个加载过程能顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。**启动类加载器还会负责加载JRE正常运行所需要的基本组件，这包括java.util,java.lang.等包中类。

### 1.24 线程上下文类加载器

> 当前类加载器(Current ClassLoader):
>
> 每个类都会使用自己的类加载器(即加载自身的类加载器)来去加载其他类(指的是它所依赖的类)
> 如果ClassX引用了ClassY，那么 ClassX类的加载器就会去加载ClassY，(前提是ClassY尚未被加载)
>
> 线程上下文类加载器 （Context ClassLoader）:
> 线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。 如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，**线程将继承其父线程的上下文类加载器,Java应用运行时的初始线程的上下文类加载器是系统类加载器(AppClassLoader)，在线程中运行的代码可以通过该类加载器来加载类与资源**。

### 1.25 线程上下类加载器的重要性

> SPI(Service Provider Interface):服务提供者接口
> **父ClassLoader可以使用当前线程T`hread.currentThread.getContextClassLoader()`所指定的classLoader加载的类**，这就改变了父ClassLoader不能使用子ClassLoader或其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
>
> **线程上下文类加载器就是当前线程的Current ClassLoader**.在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载，但对于SPI来说，有些接口是Java核心库提供的。而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(一般是厂商提供)，而Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。

> **默认的上下文类加载器都是系统类加载器，是在Launcher源码中设置的**

```java
       try {
           //获取到系统类加载器，赋值给loader
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }
        //设置当前线程上下文类加载器为 AppClassLoader
        Thread.currentThread().setContextClassLoader(this.loader);
```

### 1.26 线程上下文类加载器的一般使用模式

> * 获取
> * 使用
> * 还原
>
> myMethod()里面则调用了`Thread.currentThread().getContextClassLoader()`获取当前线程的上下文类加载器做某些起事情。
> 如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载(前提该依赖类之前还没有被加载过)**ContextClassLoader的作用就是为了破坏Java的双亲委托机制。**
> **当高层提供了统一的接口让底层去实现，同时又要在高层加载(或实例化)底层的类时，就必须要通过线程上下文 加载器来帮助高层的ClassLoader找到并加载该类。默认线程上下文类加载器就是应用类加**
> **载器(AppClassLoader)**

```java
    //获取AppClassLoader
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    try{
       //使用,  targetTccl: 你想要使用的类加载器
       Thread.currentThread().setContextClassLoader(targetTccl);
       myMethod();
     }
     finally {
       //还原成原来的 AppClassLoader
       Thread.currentThread().setContextClassLoader(classLoader)
     }
```

### 1.27 Class.forNmae() 与 ClassLoader.loadClass()区别

> * Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
> * ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
> * Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

### 1.28 双亲委派模型

> 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
>
> 双亲委派机制:
>
> 1、当`AppClassLoader`加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器`ExtClassLoader`去完成。
>
> 2、当`ExtClassLoader`加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给`BootStrapClassLoader`“`去完成。
>
> 3、如果`BootStrapClassLoader`加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用`ExtClassLoader`来尝试加载；
>
> 4、若`ExtClassLoader`也加载失败，则会使用`AppClassLoader`来加载，如果`AppClassLoader`也加载失败，则会报出异常`ClassNotFoundException`。 

## 2. 字节码文件结构

> * 使用javap -verbose命令分析一个字形码文件时，将会分析该**字形码的魔数，版本号，常量池，类信息，类的构造方法，类中方法信息，类变量与成员变量等信息。**
> * 魔数：所有的.class字形码文件的前4个字节都是魔数，**魔数值为固定值：0xCA FE BA BE(咖啡宝贝)**
> * 魔数之后的4个字节为版本信息，**前两个字节表示minor version(次版本号)，后两个字节为表示major version(主版本号).**例如 00 00 0034,换算成十进制，表示次版本号为：0，主版本号为：52。所以，该文件的版本为：1.8.0.可以通过java -version命令来验证。
> * 常量池(constant pool)：紧接着主版本号之后的就是常量池入口。一个Java类定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是 Class文件的资源仓库。比如说：Java类中定义的方法与变量
>   信息，都是存储在常量池中。**常量池中主要存储两类常量：字面量与符号引用。**
>   * **字面量：文本字符串，Java中声明为final的常量值**
>   * **符号引用：类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。**
> * 常量池的总体结构：**Java类所对应的常量池主要由常量池数量与常量池数组(常量表)这两部分共同构成**。**常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。**常量池数组与一般的数组不同的是：常量池数组中不同的元素的类型，结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是一个标志位，占据1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 - 1(其中0暂时不使用)。目的是满足某些常量池索引值的数据在特定情况下需要表达：不引用任何一个常量池的含义；根本原因在于，索引为0也是一个常量(保留常量)，只不过它不位于常量表中，这个常量就对应null值。所以，常量池的索引从1而非0开始。

### 2.1 

> 在JVM规范中，每个变量/字段都有描述信息，描述信息主要是描述字段的数据类型，方法的参数列表(包括数量，类型与顺序)与返回值。
> 根据描述符规则，**基本数据类型和代表无返回值的void类型都是用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。**
>
> 对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录 [ I
>
> `String[][]` 被记录为 [ [ Ljava/lang/String;
>
> 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组 () 之内，如方法:`StringgetRealNamyById(int id,String name)`的描述符为:
> **(I,Ljava/lang/String;) Ljava/lang/String;**
>
> 为了压缩字节码文件的体积 。对于基本数据类型，JVM都只使用一个大写字母表示，如下所示

`B - byte ,C - char ,D - double,F - float,I - int,J - long,S - short,Z -boolean,V -void,L - 对象类（Ljava/lang/String;）`

42