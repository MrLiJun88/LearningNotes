# JVM(尚一)

## 1. JVM的架构模型

> Java编译器输入的指令流基本上是一种基于**栈的指令集架构**，另外一种指令集架构则是**基于寄存器的指令集架构。**
>
> 具体来说：这两种架构之间的区别：
>
> * **基于栈式架构的特点：**
>   * 设计和实现更简单，适用于资源受限的系统
>   * 避开了寄存器分配难题，使用零地址指令方式分配
>   * 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器容易实现
>   * **不需要硬件支持，可移植性更好，更好实现跨平台**
> * **基于寄存器架构的特点：**
>   * 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
>   * **指令集架构则完全依赖硬件，可移植性差**
>   * **性能优秀和执行更高效**
>   * 花费更少的指令去完成一项操作
>   * 在大部分情况下，基于寄存器架构的指令集往往都是一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

## 2. 用户自定义类加载器实现步骤

> * 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求。
> * 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写`loadClass()`方法，从而实现自定义的类加载器，但是在JDK1.2之后，已不再建议用户去覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中。
> * 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承`URLClassLoader`类，这样就可以避免自己去编写`findClass()`方法以及获取字节码流的方式，使自定义类加载器编写更加简洁。

## 3. 双亲委派机制

> * Java虚拟机对class文件采用的是**按需加载的方式**，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由父类处理，它是一种任务委派模式。

## 4. 沙箱安全机制

> * 自定义String类，但在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String。这样可以保证对java核心源代码的保护，这就是**沙箱安全机制**。

## 5. 线程

> * 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。
> * 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。
>   * 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
> * 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。

42