# 数据结构与算法

## 1. 单链表

> 链表是一种用于存储数据集合的数据结构
>
> * 相邻元素之间通过指针连接
> * 最后一个元素后的后继指针值为null
> * 在程序执行过程中，链表的长度可以增加或缩小
> * 链表的空间能够按需分配(直到系统内存耗尽)
> * 没有内存空间的浪费(但是在链表中的指针需要一些额外的内存开销)

### 1.1 单项链表

> * 遍历链表
> * 在链表中插入一个元素
> * 在链表中删除一个元素

### 1.2 在指定位置插入节点

```java
/**按指定位置添加元素*/
    public void insertNodeAtPosition(Node newNode,int position){
        /**在链表开头位置插入*/
        if(1 == position){
            newNode.next = headNode;
            headNode = newNode;
        }
        else {
            Node preNode = headNode;
            int count = 1;
            while(count < position - 1){
                preNode = preNode.next;
                count++;
            }
            Node currentNode = preNode.next;
            newNode.next = currentNode;
            preNode.next = newNode;
        }
    }
```

### 1.2 在指定位置删除节点

```java
public void deleteNodeAtPosition(int position){
        /**删除开头元素*/
        if(1 == position){
            Node currentNode = headNode.next;
            headNode = null;
            headNode = currentNode
        }
        else {
            Node preNode = headNode;
            int count = 1;
            while(count < position - 1){
                preNode = preNode.next;
                count++;
            }
            Node currentNode = preNode.next;
            preNode.next = currentNode.next;
            currentNOde = null;
        }
    }
```

### 1.3 删除单向链表

```java
 public void deleteList(){
        Node currentNode,tempNode = headNode;
        while(null != tempNode){
            currentNode = tempNode.next;
            tempNode = null;
            tempNode = currentNode;
        }
    }
```

## 2. 双向链表

### 2.1 向双向链表中指定的位置插入元素

```java
 /**按指定位置添加元素*/
    public void insertNodeAtPosition(DoubleNode node,int position){
        /**在链表头插入元素*/
        if(1 == position){
            node.next = headNode;
            headNode.previous = node;
            headNode = node;
        }
        else {
           /**
            * tempNode为要插入位置的前一个元素
            */
            int count = 1;
            DoubleNode preNode = headNode;

            while(count < position -1 ){
                preNode = preNode.next;
                count++;
            }
            DoubleNode currentNode = preNode.next;
            node.next = currentNode;
            /**判断是否在表尾位置插入元素*/
            if(null != currentNode){
                currentNode.previous = node;
            }
            preNode.next = node;
            node.previous = preNode;
        }
    }
```

### 2.2 向双向链表中指定的位置删除元素

```java
public void deleteNodeAtPosition(int position){
        /**删除链表的表头元素*/
        if(1 == position){
            DoubleNode currentNode = headNode.next;
            headNode = null;
            currentNode.previous = null;
            headNode = currentNode;
        }
        else {
           
            int count = 1;
            DoubleNode preNode = headNode.next;
            /**preNode指向的是要删除位置的前一个元素*/
            while(count < position - 1){
                preNode = preNode.next;
                count++;
            }
            DoubleNode currentNode = preNode.next;
            DoubleNode laterNode = currentNode.next;
            preNode.next = laterNode;
            /**判断是否是表尾元素*/
            if(null != laterNode){
                laterNode.previous = preNode;
            }
            currentNode = null;
        }
    }
```

## 3. 循环链表

> 在循环链表中，使用表头节点访问元素(与单向链表和双向链表中的表头节点相类似)

### 3.1 在循环链表尾插入结点

```java
    /**在循环链表的表尾添加节点*/
    public void insertNodeInCirListEnd(CirNode newNode){
        CirNode currentNode = headNode;
        while(headNode != currentNode.next){
            currentNode = currentNode.next;
        }
        newNode.next = headNode;
        currentNode.next = newNode;
    }
```

### 3.2 在循环链表头插入结点

```java
    /**在循环链表头插入节点*/
    public void insertNodeInCirListStart(CirNode newNode){
        CirNode currentNode = headNode;
        while(headNode != currentNode.next){
            currentNode = currentNode.next;
        }
        newNode.next = headNode;
        currentNode.next = newNode;
        headNode = newNode;
    }
```

### 3.3 删除循环链表中最后一个结点

```java
    /**删除循环链表的最后一个节点*/
    public void deleteNodeInCirListEnd(){
        CirNode tempNode = headNode;
        CirNode currentNode = headNode;
        while(currentNode.next != headNode){
            tempNode = currentNode;
            currentNode = currentNode.next;
        }
        tempNode.next = headNode;
        currentNode = null;
    }
```

### 3.4 逆序输出链表元素

> 使用递归方法

```java
    /**逆序输出链表元素*/
    public void showListReverseOrder(Node headNode){
        if(null == headNode){
            return;
        }
        this.showListReverseOrder(headNode.next);
        System.out.print(headNode.data + " ");
    }
```

### 3.5 有序合并两个有序链表

> 使用递归方式 

```java
/**合并两个有序链表*/
    public Node mergeListForAsc(Node a,Node b){
        Node result = null;
        if(null == a) {
            return b;
        }
        if(null == b) {
            return a;
        }
        if(a.data <= b.data){
            result = a;
            result.next = this.mergeListForAsc(a.next,b);
        }
        else {
            result = b;
            result.next = this.mergeListForAsc(a,b.next);
        }
        return result;
    }
```

### 3.6 逐对逆置链表

> 设：1 -> 2 -> 3 -> 4 -> X 
>
> 结果：2 -> 1 -> 4 -> 3 -> X

```java
 
```

